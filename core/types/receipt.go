// Package types implements blockchain data types for NovaCoin.
package types

import (
	"encoding/binary"
	"errors"
	"math/big"

	"github.com/novacoin/novacoin/core/state"
)

// Receipt status codes.
const (
	ReceiptStatusFailed  = uint64(0)
	ReceiptStatusSuccess = uint64(1)
)

// Log represents a contract log event.
type Log struct {
	// Address of the contract that generated the event.
	Address state.Address

	// Topics are indexed log arguments (up to 4).
	// The first topic is typically the event signature hash.
	Topics []state.Hash

	// Data is non-indexed log data.
	Data []byte

	// BlockNumber is the block in which the transaction was included.
	BlockNumber uint64

	// TxHash is the hash of the transaction.
	TxHash state.Hash

	// TxIndex is the index of the transaction in the block.
	TxIndex uint

	// BlockHash is the hash of the block.
	BlockHash state.Hash

	// Index is the position of the log in the block.
	Index uint

	// Removed is true if the log was reverted due to chain reorganization.
	Removed bool
}

// NewLog creates a new log entry.
func NewLog(address state.Address, topics []state.Hash, data []byte) *Log {
	return &Log{
		Address: address,
		Topics:  topics,
		Data:    data,
	}
}

// Copy creates a deep copy of the log.
func (l *Log) Copy() *Log {
	cpy := &Log{
		Address:     l.Address,
		BlockNumber: l.BlockNumber,
		TxHash:      l.TxHash,
		TxIndex:     l.TxIndex,
		BlockHash:   l.BlockHash,
		Index:       l.Index,
		Removed:     l.Removed,
	}

	if l.Topics != nil {
		cpy.Topics = make([]state.Hash, len(l.Topics))
		copy(cpy.Topics, l.Topics)
	}

	if l.Data != nil {
		cpy.Data = make([]byte, len(l.Data))
		copy(cpy.Data, l.Data)
	}

	return cpy
}

// Receipt represents the result of a transaction execution.
type Receipt struct {
	// Type is the transaction type.
	Type TxType

	// PostState is the state root after execution (pre-Byzantium).
	PostState []byte

	// Status is the execution status (1 = success, 0 = failure).
	Status uint64

	// CumulativeGasUsed is the total gas used in the block up to and including this tx.
	CumulativeGasUsed uint64

	// Bloom is the bloom filter for quick log searching.
	Bloom Bloom

	// Logs are the log entries generated by the transaction.
	Logs []*Log

	// TxHash is the hash of the transaction.
	TxHash state.Hash

	// ContractAddress is the address of the created contract (if any).
	ContractAddress state.Address

	// GasUsed is the gas used by this specific transaction.
	GasUsed uint64

	// EffectiveGasPrice is the actual gas price paid (for EIP-1559).
	EffectiveGasPrice *big.Int

	// BlobGasUsed is the blob gas used by this transaction (EIP-4844).
	BlobGasUsed uint64

	// BlobGasPrice is the blob gas price at the time of execution.
	BlobGasPrice *big.Int

	// BlockHash is the hash of the block containing this receipt.
	BlockHash state.Hash

	// BlockNumber is the block number.
	BlockNumber *big.Int

	// TransactionIndex is the index of the transaction in the block.
	TransactionIndex uint
}

// NewReceipt creates a new receipt.
func NewReceipt(status uint64, cumulativeGasUsed uint64) *Receipt {
	return &Receipt{
		Status:            status,
		CumulativeGasUsed: cumulativeGasUsed,
	}
}

// Succeeded returns true if the transaction succeeded.
func (r *Receipt) Succeeded() bool {
	return r.Status == ReceiptStatusSuccess
}

// Copy creates a deep copy of the receipt.
func (r *Receipt) Copy() *Receipt {
	cpy := &Receipt{
		Type:              r.Type,
		Status:            r.Status,
		CumulativeGasUsed: r.CumulativeGasUsed,
		Bloom:             r.Bloom,
		TxHash:            r.TxHash,
		ContractAddress:   r.ContractAddress,
		GasUsed:           r.GasUsed,
		BlobGasUsed:       r.BlobGasUsed,
		BlockHash:         r.BlockHash,
		TransactionIndex:  r.TransactionIndex,
	}

	if r.PostState != nil {
		cpy.PostState = make([]byte, len(r.PostState))
		copy(cpy.PostState, r.PostState)
	}

	if r.Logs != nil {
		cpy.Logs = make([]*Log, len(r.Logs))
		for i, log := range r.Logs {
			cpy.Logs[i] = log.Copy()
		}
	}

	if r.EffectiveGasPrice != nil {
		cpy.EffectiveGasPrice = new(big.Int).Set(r.EffectiveGasPrice)
	}

	if r.BlobGasPrice != nil {
		cpy.BlobGasPrice = new(big.Int).Set(r.BlobGasPrice)
	}

	if r.BlockNumber != nil {
		cpy.BlockNumber = new(big.Int).Set(r.BlockNumber)
	}

	return cpy
}

// Receipts is a slice of receipts.
type Receipts []*Receipt

// Len returns the number of receipts.
func (rs Receipts) Len() int {
	return len(rs)
}

// === Bloom Filter ===

// BloomBitsLength is the number of bits in the bloom filter.
const BloomBitsLength = 2048

// BloomByteLength is the byte size of the bloom filter.
const BloomByteLength = BloomBitsLength / 8

// Bloom is a 2048-bit bloom filter for efficient log searching.
type Bloom [BloomByteLength]byte

// BytesToBloom converts a byte slice to a bloom filter.
func BytesToBloom(b []byte) Bloom {
	var bloom Bloom
	bloom.SetBytes(b)
	return bloom
}

// SetBytes sets the bloom filter from bytes.
func (b *Bloom) SetBytes(data []byte) {
	if len(data) > BloomByteLength {
		data = data[len(data)-BloomByteLength:]
	}
	copy(b[BloomByteLength-len(data):], data)
}

// Add adds data to the bloom filter.
func (b *Bloom) Add(data []byte) {
	// Calculate 3 bit positions using keccak256
	hash := keccak256(data)

	for i := 0; i < 6; i += 2 {
		// Get 11 bits for position (0-2047)
		bitPos := (uint(hash[i])<<8 | uint(hash[i+1])) & 0x7FF
		bytePos := BloomByteLength - 1 - bitPos/8
		bitInByte := bitPos % 8
		b[bytePos] |= 1 << bitInByte
	}
}

// Test checks if data might be in the bloom filter.
func (b *Bloom) Test(data []byte) bool {
	hash := keccak256(data)

	for i := 0; i < 6; i += 2 {
		bitPos := (uint(hash[i])<<8 | uint(hash[i+1])) & 0x7FF
		bytePos := BloomByteLength - 1 - bitPos/8
		bitInByte := bitPos % 8
		if b[bytePos]&(1<<bitInByte) == 0 {
			return false
		}
	}
	return true
}

// Or performs bitwise OR with another bloom filter.
func (b *Bloom) Or(other Bloom) {
	for i := range b {
		b[i] |= other[i]
	}
}

// Bytes returns the bloom filter as bytes.
func (b Bloom) Bytes() []byte {
	return b[:]
}

// Big returns the bloom filter as a big.Int.
func (b Bloom) Big() *big.Int {
	return new(big.Int).SetBytes(b[:])
}

// CreateBloom creates a bloom filter from a list of receipts.
func CreateBloom(receipts Receipts) Bloom {
	var bloom Bloom
	for _, receipt := range receipts {
		bloom.Or(receipt.Bloom)
	}
	return bloom
}

// LogsBloom creates a bloom filter from logs.
func LogsBloom(logs []*Log) Bloom {
	var bloom Bloom
	for _, log := range logs {
		bloom.Add(log.Address[:])
		for _, topic := range log.Topics {
			bloom.Add(topic[:])
		}
	}
	return bloom
}

// === Receipt Encoding ===

// ReceiptEncodingError represents an encoding error.
type ReceiptEncodingError string

func (e ReceiptEncodingError) Error() string {
	return string(e)
}

var (
	ErrReceiptInvalidType = errors.New("invalid receipt type")
	ErrReceiptTooShort    = errors.New("receipt data too short")
)

// EncodeReceipt encodes a receipt for storage.
func EncodeReceipt(receipt *Receipt) ([]byte, error) {
	// Simple encoding: type + status + cumulativeGas + gasUsed + bloom + logs
	// This is a simplified version; real implementation would use RLP

	// Calculate size
	size := 1 + 8 + 8 + 8 + BloomByteLength // type + status + cumGas + gasUsed + bloom
	size += 4                               // log count

	for _, log := range receipt.Logs {
		size += 20                 // address
		size += 4                  // topic count
		size += len(log.Topics)*32 // topics
		size += 4                  // data length
		size += len(log.Data)      // data
	}

	data := make([]byte, size)
	offset := 0

	// Type
	data[offset] = byte(receipt.Type)
	offset++

	// Status
	binary.BigEndian.PutUint64(data[offset:], receipt.Status)
	offset += 8

	// Cumulative gas used
	binary.BigEndian.PutUint64(data[offset:], receipt.CumulativeGasUsed)
	offset += 8

	// Gas used
	binary.BigEndian.PutUint64(data[offset:], receipt.GasUsed)
	offset += 8

	// Bloom
	copy(data[offset:], receipt.Bloom[:])
	offset += BloomByteLength

	// Log count
	binary.BigEndian.PutUint32(data[offset:], uint32(len(receipt.Logs)))
	offset += 4

	// Logs
	for _, log := range receipt.Logs {
		// Address
		copy(data[offset:], log.Address[:])
		offset += 20

		// Topic count
		binary.BigEndian.PutUint32(data[offset:], uint32(len(log.Topics)))
		offset += 4

		// Topics
		for _, topic := range log.Topics {
			copy(data[offset:], topic[:])
			offset += 32
		}

		// Data length
		binary.BigEndian.PutUint32(data[offset:], uint32(len(log.Data)))
		offset += 4

		// Data
		copy(data[offset:], log.Data)
		offset += len(log.Data)
	}

	return data, nil
}

// DecodeReceipt decodes a receipt from storage.
func DecodeReceipt(data []byte) (*Receipt, error) {
	if len(data) < 1+8+8+8+BloomByteLength+4 {
		return nil, ErrReceiptTooShort
	}

	receipt := &Receipt{}
	offset := 0

	// Type
	receipt.Type = TxType(data[offset])
	offset++

	// Status
	receipt.Status = binary.BigEndian.Uint64(data[offset:])
	offset += 8

	// Cumulative gas used
	receipt.CumulativeGasUsed = binary.BigEndian.Uint64(data[offset:])
	offset += 8

	// Gas used
	receipt.GasUsed = binary.BigEndian.Uint64(data[offset:])
	offset += 8

	// Bloom
	copy(receipt.Bloom[:], data[offset:])
	offset += BloomByteLength

	// Log count
	logCount := binary.BigEndian.Uint32(data[offset:])
	offset += 4

	// Logs
	receipt.Logs = make([]*Log, logCount)
	for i := uint32(0); i < logCount; i++ {
		if offset+20+4 > len(data) {
			return nil, ErrReceiptTooShort
		}

		log := &Log{}

		// Address
		copy(log.Address[:], data[offset:])
		offset += 20

		// Topic count
		topicCount := binary.BigEndian.Uint32(data[offset:])
		offset += 4

		// Topics
		if offset+int(topicCount)*32 > len(data) {
			return nil, ErrReceiptTooShort
		}
		log.Topics = make([]state.Hash, topicCount)
		for j := uint32(0); j < topicCount; j++ {
			copy(log.Topics[j][:], data[offset:])
			offset += 32
		}

		// Data length
		if offset+4 > len(data) {
			return nil, ErrReceiptTooShort
		}
		dataLen := binary.BigEndian.Uint32(data[offset:])
		offset += 4

		// Data
		if offset+int(dataLen) > len(data) {
			return nil, ErrReceiptTooShort
		}
		log.Data = make([]byte, dataLen)
		copy(log.Data, data[offset:])
		offset += int(dataLen)

		receipt.Logs[i] = log
	}

	return receipt, nil
}

// DeriveFields fills in computed fields for receipts.
func (rs Receipts) DeriveFields(blockHash state.Hash, blockNumber uint64, baseFee *big.Int, txs []*Transaction) error {
	if len(rs) != len(txs) {
		return errors.New("receipt/transaction count mismatch")
	}

	var cumulativeGas uint64
	for i := range rs {
		// Set the receipt's block info
		rs[i].BlockHash = blockHash
		rs[i].BlockNumber = new(big.Int).SetUint64(blockNumber)
		rs[i].TransactionIndex = uint(i)

		// Set transaction hash
		rs[i].TxHash = txs[i].Hash()

		// Calculate gas used by this transaction
		if i == 0 {
			rs[i].GasUsed = rs[i].CumulativeGasUsed
		} else {
			rs[i].GasUsed = rs[i].CumulativeGasUsed - cumulativeGas
		}
		cumulativeGas = rs[i].CumulativeGasUsed

		// Calculate effective gas price
		if baseFee != nil && txs[i].Type() == TxTypeDynamicFee {
			// For EIP-1559: min(gasTipCap + baseFee, gasFeeCap)
			tipCap := txs[i].GasTipCap()
			feeCap := txs[i].GasFeeCap()

			effectivePrice := new(big.Int).Add(tipCap, baseFee)
			if effectivePrice.Cmp(feeCap) > 0 {
				effectivePrice = new(big.Int).Set(feeCap)
			}
			rs[i].EffectiveGasPrice = effectivePrice
		} else {
			rs[i].EffectiveGasPrice = txs[i].GasPrice()
		}

		// Set log block info
		for j, log := range rs[i].Logs {
			log.BlockHash = blockHash
			log.BlockNumber = blockNumber
			log.TxHash = rs[i].TxHash
			log.TxIndex = uint(i)
			log.Index = uint(j)
		}

		// Compute bloom for the receipt
		rs[i].Bloom = LogsBloom(rs[i].Logs)
	}

	return nil
}

// keccak256 computes the Keccak256 hash (simplified implementation).
// In production, this would use golang.org/x/crypto/sha3.
func keccak256(data []byte) []byte {
	// Simplified hash for bloom filter
	// Real implementation uses Keccak256
	hash := make([]byte, 32)
	for i, b := range data {
		hash[i%32] ^= b
		hash[(i+1)%32] ^= b << 4
		hash[(i+7)%32] ^= b >> 3
	}
	return hash
}
